#!/usr/bin/env bash

set -e

declare script_dir
script_dir="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"
declare repo_dir
repo_dir="$(dirname "$script_dir")"

declare local_database='ptat'
declare planetscale_org='example'
declare planetscale_database='ptat'

# load mise environment (in case we're run from outside the project directory)
eval "$(cd "$repo_dir" && mise hook-env 2> /dev/null)"

dev::usage() {
    echo 'usage: dev <command>'
    echo '       dev initial setup    # install app and dev env dependencies'
    echo '       dev reset            # deletes temp files and sets project back up'
    echo '       dev start            # run dev server'
    echo '       dev desktop          # run desktop app'
    echo '       dev android          # run android mobile app'
    echo '       dev ios              # run ios mobile app'
    echo '       dev stop             # stop dev server'
    echo '       dev lint             # run linters'
    echo '       dev lint fix         # fix auto-fixable linter errors'
    echo '       dev db seed          # run seeds'
    echo '       dev db local         # connect to local database'
    echo '       dev db prod          # connect to production database'
    echo '       dev db migrate local # migrate local database'
    echo '       dev db migrate prod  # migrate production database'
    echo '       dev env edit prod    # edit encrypted prod env vars'
    echo '       dev env edit preview # edit encrypted preview env vars'
    exit 1
}

dev::initial::setup() {
    cd "$repo_dir"

    echo '==> install brew'
    if ! type 'brew' > /dev/null 2>&1; then
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    fi

    echo '==> install dependencies'
    brew install \
        mise \
        shellcheck \
        sops age \
        homebrew/cask/docker \
        planetscale/tap/pscale \
        mysql \
        jq

    if ! type 'rustup' > /dev/null 2>&1; then
        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s - -y --no-modify-path
    fi

    echo '==> create .env'
    if [[ ! -f .env ]]; then
        echo '# override defaults from .env.local' > .env
    fi

    echo '==> allow mise to load project directory'
    mise trust --all

    if ! docker ps > /dev/null 2>&1; then
        echo '==> start docker'
        open -a 'Docker'

        echo -n '==> waiting for docker'
        while ! docker ps > /dev/null 2>&1; do
            echo -n '.'
            sleep 1
        done
        echo
    fi

    echo '==> dev reset'
    dev::reset
}

dev::reset() {
    cd "$repo_dir"

    echo '==> stop db'
    dev::stop

    echo '==> delete git ignored files'
    git clean -ffdX -e '!.env'

    echo '==> reload mise'
    mise install

    echo '==> install dependencies'
    npm install
}

dev::start() {
    trap 'dev::stop' EXIT

    # start db
    dev::db::up

    # push schema to db
    npm run -w db db:push

    # run seeds
    dev::db::seed

    # run dev
    turbo dev
}

dev::desktop() {
    npm run -w desktop desktop
}

dev::android() {
    npm run -w mobile android
}

dev::ios() {
    npm run -w mobile ios
}

dev::stop() {
    docker compose down -v
}

dev::lint() {
    check-package-lock
    shellcheck-all
    tsc -b
    eslint .
    prettier --log-level warn --check .
}

dev::lint::fix() {
    eslint --fix .
    prettier --log-level warn --write .
}

dev::db::up() {
    # start db if it's not running
    if ! mysql_local -e 'SELECT true;' > /dev/null 2>&1; then
        docker compose up -d --build --remove-orphans

        wait_for_db
    fi
}

dev::db::seed() {
    turbo db:seed
}

dev::db::local() {
    dev::db::up

    mysql_local
}

dev::db::prod() {
    planetscale_init

    pscale shell "$planetscale_database" main
}

dev::db::migrate::local() {
    dev::db::up
    npm run -w db db:push
}

dev::db::migrate::prod() {
    # NOTE: inspired by: https://planetscale.com/docs/tutorials/automatic-prisma-migrations

    planetscale_init

    # create branch
    # TODO: create branch that matches pr branch name
    declare branch="${local_database}-migrate"
    pscale branch create "$planetscale_database" "$branch" --wait

    # connect to branch
    declare port
    port="$(random_port)"
    pscale connect "$planetscale_database" "$branch" --port "$port" &
    pscale_pid="$!"
    trap '
        if [[ -n "$pscale_pid" ]]; then
            kill -INT "$pscale_pid"
        fi
    ' EXIT

    # wait for db
    wait_for_db "$port"

    # push schema changes
    export DATABASE_URL="mysql://root@127.0.0.1:${port}/${planetscale_database}"
    npm run -w db db:push

    # kill pscale connect (do this before the trap to prevent errors)
    kill -INT "$pscale_pid"
    pscale_pid=""

    # diff branch
    # NOTE: drizzle doesn't give us a way to know if changes were made, and
    # there's some delay on planetscale knowing, so we sleep a little to make
    # sure the diff is available
    sleep 5
    echo '==> Diffing branch'
    declare branch_diff
    branch_diff="$(pscale branch diff "$planetscale_database" "$branch")"

    # if changes, we create a deploy request
    if [[ -z "$branch_diff" ]]; then
        echo '==> No changes, skipping deploy'
    else
        echo "$branch_diff"

        # create deploy request
        echo '==> Creating deploy'
        declare deploy_create_response
        deploy_create_response="$(
            pscale deploy-request create --format json "$planetscale_database" "$branch"
        )"
        declare deploy_request_number
        deploy_request_number="$(jq '.number' <<< "$deploy_create_response")"
        echo "==> Deploy created (#${deploy_request_number})"

        # deploy
        echo -n '==> Waiting on deploy'
        declare exit_code=0
        declare deploy_response
        while true; do
            deploy_response="$(
                pscale \
                    deploy-request deploy \
                    "$planetscale_database" "$deploy_request_number" \
                    --wait \
                    --format json \
                    2>&1
            )" && exit_code="$?" || exit_code="$?"

            declare error
            error="$(jq -r '.error // empty' <<< "$deploy_response")"
            if [[ "$error" != "We're currently validating that these changes are safe to deploy. Please try again in a few moments." ]]; then
                # break once it's no longer validating
                break
            fi

            echo -n '.'
            sleep 1
        done
        echo

        if [[ "$exit_code" != '0' || -n "$(jq -r '.error // empty' <<< "$deploy_response")" ]]; then
            echo "$deploy_response" >&2
            return "$exit_code"
        fi

        echo '==> Deploy completed'

        # skip revert (if required)
        declare deployment_state
        deployment_state="$(
            pscale deploy-request show \
                "$planetscale_database" "$deploy_request_number" \
                --format json \
                | jq -r '.deployment_state'
        )"

        if [[ "$deployment_state" == 'complete_pending_revert' ]]; then
            echo '==> Skipping revert'
            pscale deploy-request skip-revert \
                "$planetscale_database" "$deploy_request_number"
        fi
    fi

    # delete branch
    echo '==> Deleting branch'
    pscale branch delete "$planetscale_database" "$branch" --force
}

mysql_local() {
    MYSQL_PWD=password mysql -h127.0.0.1 -uroot "$local_database" "$@"
}

wait_for_db() {
    declare port="${1:-3306}"

    echo -n '==> Waiting for db' >&2
    until mysql_local --port="$port" -e 'SELECT true;' > /dev/null 2>&1; do
        echo -n '.' >&2
        sleep 1
    done
    echo >&2
}

random_port() {
    # NOTE: I don't love calling out to python but, doing this any other way in
    # bash either involves much more code, or much worse semantics
    python3 -c 'import socket; s = socket.socket(); s.bind(("", 0)); print(s.getsockname()[1]); s.close()'
}

planetscale_init() {
    # NOTE: pscale auth check doesn't work with service tokens
    if [[ -n "$PLANETSCALE_SERVICE_TOKEN" &&
        -n "$PLANETSCALE_SERVICE_TOKEN_ID" &&
        -n "$PLANETSCALE_ORG" ]] \
        ; then
        return
    fi

    # login
    # TODO: https://github.com/planetscale/cli/issues/836
    # NOTE: `pscale auth check` is insufficient because when a token expires, it's still considered authenticated:
    # pscale auth check; echo -e "\nexit: $?"
    # You are authenticated.
    # exit: 0
    if ! pscale org list > /dev/null 2>&1; then
        pscale auth login
    fi

    # switch org
    declare org_response
    org_response="$(pscale org show --format json 2> /dev/null)"
    if [[ "$(jq -r '.org' <<< "$org_response")" != "$planetscale_org" ]]; then
        pscale org switch "$planetscale_org"
    fi
}

dev::env::edit::prod() {
    sops "$@" .env.production.yml
}

dev::env::edit::preview() {
    sops "$@" .env.preview.yml
}

case "$*" in
    'initial setup') dev::initial::setup ;;
    reset) dev::reset ;;
    start) dev::start ;;
    desktop) dev::desktop ;;
    android) dev::android ;;
    ios) dev::ios ;;
    stop) dev::stop ;;
    lint) dev::lint ;;
    'lint fix') dev::lint::fix ;;
    'db seed') dev::db::seed ;;
    'db local') dev::db::local ;;
    'db prod') dev::db::prod ;;
    'db migrate local') dev::db::migrate::local ;;
    'db migrate prod') dev::db::migrate::prod ;;
    'env edit prod'*) dev::env::edit::prod "${@:4}" ;;
    'env edit preview'*) dev::env::edit::preview "${@:4}" ;;
    *) dev::usage ;;
esac
